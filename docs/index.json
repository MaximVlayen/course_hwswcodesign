[
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/",
	"title": "1 Processor",
	"tags": [],
	"description": "",
	"content": "Processor Image courtesy: Pexels - Pok Rie "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/101_processor/",
	"title": "101 - Processor",
	"tags": [],
	"description": "",
	"content": "Hello world !!\nEvery computer(-like) system has a processor at the heart of its system. Throughout this program you have encountered a number of them already, in different sizes and with different capabilities. There was the Arduino in 2Ba which has an 8-bit Atmel AVR controller; the (most recent version of) SoC-lab course uses the 32-bit soft-core MicroBlaze processor; and (without being able to give the specs) there is of course the processor in your laptop.\nIn this course, the techniques of hardware-software codesign are explored.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/102_riscv/",
	"title": "102 - RISC-V",
	"tags": [],
	"description": "",
	"content": "As you know by know, computers speak a different language than us, humans. Also, different computers don\u0026rsquo;t speak the same language, although some similarities can be detected. Where all our words in the English or Dutch language are nicely summarised in a dictionary. Similarly, the words that a processor speaks are summarised in an instruction set.\nWhen we hear stories, from a certain level of abstraction these stories are simply a collection of words that occur in the dictionary. This concept also translates to a processor in the form of a program. A program is set of instructions put in a specific order to tell a story, or achieve a certain functionality.\nTo interpret and execute a program, an architecture is needed. Such a computer architecture is a model on how the list of instructions should be executed. A frequently used instruction set architecture (ISA) is the load-store architecture. This technique is used by the PowerPC, a MIPS processor, an ARM core \u0026hellip; and the RISC-V. Another famous ISA is the register-memory architecture. This is used by the Intel x86 and the Motorola 68000 series.\nThe difference between a load-store architecture and a register-memory architecture can be illustrated using an example: add a, b, c. This instruction has the processor calculate the sum of b and c and places the result in a. In a load-store architecture all three locations (a, b, and c) must be residing in a register. In a register-memory architecture these locations can also reside in memory.\nIn 2011 the University of California, Berkely published the \u0026lt;strong\u0026gt;RISC-V Instruction Set Manual\u0026lt;/strong\u0026gt;. The full history of RISC-V can be found on their website. This original specification has undergone quite some change. The most recent version (at the moment of writing) is December 16, 2021 and can be found here. Finally it is pointed out that RISC-V ISA is completely open and freely available to academia and industry ðŸ˜ƒ.\nA word from the instruction set is (for this course) assumed to be 32 bits. Such a 32-bit word can mean anything in the world until a consensus is achieved on how to interpret these words. This is done in the RISC-V ISA and will be shortly (re-)visit below.\nHaving any idea, like the RISC-V, on paper is an important step. Of course, even the best design on paper is not running any programs. An implementation of the described ideas has to be made. For this course an existing implementation of RISC-V will used: the PicoRV32. This implementation is a hardware description of a RISC-V processor and is optimised for size.\nRISC-V instruction formats The core instructions in RISC-V can be grouped in 6 different formats:\nR-format: these are instructions with 3 register inputs I-format: these are instructions with immediates and loads S-format: these are store instructions SB-format: these are branch instructions U-format: these are store instructions wit hupper immediates UJ-format: these are jump instructions Depending on the format of the instruction, it should be interpreted differently. RISC-V instruction sub-sets Although there are many instructions defined in the instruction set, different subsets are made. The base instruction set exists in 3 different sizes: 32, 64 and 128 bits. These are named RV32I,RV64I, and RV128I respectively. In the 64-bit subset, registers are 64 bits wide; and the 128-bit subset increases this even to 128 bits. The need for the latter is debatable (and out of scope here). The base instructions sets all support instructions for basic integer operations. In the I variant there are 32 registers while in the E variant only 16 registers are required.\nDifferent extensions are also proposed.\nM: Instructions for multiplication and division C: Compact instructions that have only 16-bit encoding. This extension is very important for applications requiring low memory footprint. F: Single-precision floating-point instructions D: Double-precision floating-point instructions A: Atomic memory instructions B: Bit manipulation instructions. The extension contains instructions used for bit manipulations, such as rotations or bit set/clear instructions. V: Vector instructions that can be used for HPC. P: DSP and packed SIMD instructions needed for embedded DSP processors. The naming of the instruction sub-set hence defines what should be supported by the architecture and the implementation; for example: an RV64IM, or a RV32IMFB.\nFrom the README-file in the GitHub repository of the PicoRV can be read:\nPicoRV32 is a CPU core that implements the RISC-V RV32IMC Instruction Set. It can be configured as RV32E, RV32I, RV32IC, RV32IM, or RV32IMC core, and optionally contains a built-in interrupt controller.\nThis means that all the configurations are 32-bit implementations that have 32 or 16 registers. Also the required base instruction set is present, and there are options to also enable the multiplication and division instructions; and (as the name suggests) there is an option for having compact instructions.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/103_picorv/",
	"title": "103 - PicoRV32",
	"tags": [],
	"description": "",
	"content": "RISC-V is not a processor, but a specification. Of course there is the Internet and plenty of people have made an implementation for this specification. In this course we\u0026rsquo;ll be working with the \u0026lt;strong\u0026gt;PicoRV32\u0026lt;/strong\u0026gt;. The entity (or module) looks like the image below.\nNative memory interface The PicoRV32 has a simple memory interface. It allows for a single memory transfer at a time. Every transaction is initiated by the PicoRV32 core, by raising mem_valid. The receiving peer will acknowledge the request through mem_ready.\nA normal memory transfer\u0026rsquo;s handshake.\nAn instruction memory transfer\u0026rsquo;s handshake.\nA standard read transfer Upon doing a read transfer mem_wdata is not used and mem_wstrb is fixed at 0x0. The address of which the data is requested is presented at mem_addr. The data that is read is presented back at the PicoRV32 through the mem_rdata bus and is valid simultaneously with mem_ready. A standard write transfer Upon doing a write transfer mem_rdata is not used and mem_wstrb must be used. The address at which the data is to written is presented at mem_addr. Simultaneously, the mem_wdata presents the value to be stored. The operation is acknowledged by the peer through mem_ready. The mem_wstrb bus indicates which bytes in the 32-bit word are valid.\nNote that not all 16 possible values for mem_wstrb are allowed. Only these values are valid: 0000, 1111, 1100, 0011, 1000, 0100, 0010, and 0001.\nBoth for the read and write transfers there is no need for a waiting cycle. If the peer (memory) acknowledges, work can continue. Finally, the PicoRV32 core also provides a Look-Ahead Memory Interface that provides all information about the next memory transfer one clock cycle earlier than the normal interface.\nIn the clock cycle before mem_valid goes high, this interface will output a pulse on mem_la_read or mem_la_write to indicate the start of a read or write transaction in the next clock cycle.\nThe signals mem_la_read, mem_la_write, and mem_la_addr are driven by combinatorial circuits within the PicoRV32 core. It might be harder to achieve timing closure with the look-ahead interface than with the normal memory interface described above.\nInterrupts The PicoRV32 can be enabled to use interrupts through the parameter ENABLE_IRQ. The build-in interrupt controller supports 32 interrupt inputs (IRQ) which are acknowledged by the PicoRV32 through the end-of-interrupt (eoi) signal.\nThe IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification. Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.\nPico Co-Processor Interface (PCPI) The co-processor interface will be discussed in detail in the next chapter.\nSimulation Simply creating a Vivado project with the code from the PicoRV32 GitHub repository allows you to run a simulation. As can be seen from the waveforms below, the core starts reading from address 0x0. By default (if no instruction dictates otherwise) the program counter is incremented with 0x4 after every instruction.\nThe reason for incrementing the address with 4 instead of 1 lies in addressability of bytes. As every address points to a 32-bit word, the smallest unit would be 32 bits. However, sometimes only one byte is targeted. Selecting offsets within a 32-bit word can thus be provided.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/104_crosscomp/",
	"title": "104 - Cross compiling",
	"tags": [],
	"description": "",
	"content": "To make a program run on the PicoRV32, it has to be written first. The software that is written in this course will be in C. Of course, the processor does not understand C instructions. As you have seen in earlier courses, the C-code is first compiled and then linked to end up with a binary. This binary contains machine code that can be ran on the processor.\nIf the machine on which the compiler and linker are executed differs from the target machine that is to execute the program, the term cross-compilation is used.\nAll examples in this course were compiled with the riscv32-unknown-elf-gcc. For more information on installing this toolchain please use Google (e.g. here).\nBare metal Bare metal programming is writing software that is not running on an Operating System (OS). You probably have done this when (maybe unknowingly) programming an Arduino or another microprocessor.\nfirmware.c #include \u0026#34;print.h\u0026#34; void main(void) { print_str(\u0026#34;hello world\\n\u0026#34;); } The simplest (but still traditional) code that you can imagine is shown here: a simple print of the string hello word. Even with 4 lines of code 2 things should be highlighted.First of all, no include of stdio.h is done, but \u0026ldquo;print.h\u0026rdquo; is included. And secondly, the printing function is print_str() contrary to the traditional printf().\nAs there is no operating system, we have no access to functions other than to those that we write ourselves. Luckily the repository of the PicoRV32 provides example print functionality. With the include of firmware.h two basic header files are included and 4 forward declarations are done.\nprint.h // This is free and unencumbered software released into the // public domain. Anyone is free to copy, modify, publish, // use, compile, sell, or distribute this software, either // in source code form or as a compiled binary, for any // purpose, commercial or non-commercial, and by any means. #ifndef FIRMWARE_H #define FIRMWARE_H #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; // print.c void print_chr(char ch); void print_str(const char *p); void print_dec(unsigned int val); void print_hex(unsigned int val, int digits); #endif With these four functions, there is an opportunity to print a character, a string (as in a list of characters), a decimal value, or a hexadecimal value. A logical question would be: \u0026ldquo;Where is my character (or other variable) printed ?\u0026rdquo;. The answer lies in this line:\n*((volatile uint32_t*)OUTPORT) = ch; Letâ€™s break this down for those whose C-skills are a bit rusty. The define OUTPORT makes sure that, everywhere in the code this define is substituted by the 32-bit number 0x10000000. This value is type-cast to an unsigned 32-bit pointer((volatile uint32_t*)). The keyword volatile states that the content of a variable can also be altered from another source. This is important !! Otherwise the optimisation of the C-compiler might optimise-out certain lines of C-code. Finally, that address is dereferenced to target the memory that is located at address 0x10000000.\nprint.c // This is free and unencumbered software released into the // public domain. Anyone is free to copy, modify, publish, // use, compile, sell, or distribute this software, either // in source code form or as a compiled binary, for any // purpose, commercial or non-commercial, and by any means. #include \u0026#34;print.h\u0026#34; #define OUTPORT 0x10000000 void print_chr(char ch) { *((volatile uint32_t*)OUTPORT) = ch; } void print_str(const char *p) { while (*p != 0) *((volatile uint32_t*)OUTPORT) = *(p++); } void print_dec(unsigned int val) { char buffer[10]; char *p = buffer; while (val || p == buffer) { *(p++) = val % 10; val = val / 10; } while (p != buffer) { *((volatile uint32_t*)OUTPORT) = \u0026#39;0\u0026#39; + *(--p); } print_chr(\u0026#39;\\n\u0026#39;); } void print_hex(unsigned int val, int digits) { for (int i = (4*digits)-4; i \u0026gt;= 0; i -= 4) *((volatile uint32_t*)OUTPORT) = \\ \u0026#34;0123456789ABCDEF\u0026#34;[(val \u0026gt;\u0026gt; i) % 16]; print_chr(\u0026#39;\\n\u0026#39;); } Typically, the one function that has to be present in every C-program is the main() function. This function is called by the OS to start of the program. As in bare metal programming there is no OS, some form of booting-process needs to be defined. The PicoRV32 comes with an example assembly file that can be simplified to the script below.\nstart.S .section .init .global main start: /* zero-initialize all registers */ addi x1, zero, 0 addi x2, zero, 0 addi x3, zero, 0 addi x4, zero, 0 addi x5, zero, 0 addi x6, zero, 0 addi x7, zero, 0 addi x8, zero, 0 addi x9, zero, 0 addi x10, zero, 0 addi x11, zero, 0 addi x12, zero, 0 addi x13, zero, 0 addi x14, zero, 0 addi x15, zero, 0 addi x16, zero, 0 addi x17, zero, 0 addi x18, zero, 0 addi x19, zero, 0 addi x20, zero, 0 addi x21, zero, 0 addi x22, zero, 0 addi x23, zero, 0 addi x24, zero, 0 addi x25, zero, 0 addi x26, zero, 0 addi x27, zero, 0 addi x28, zero, 0 addi x29, zero, 0 addi x30, zero, 0 addi x31, zero, 0 /* set stack pointer */ lui sp, 4 addi sp, sp, 0 /* call main */ jal ra, main /* break - trap */ ebreak firmware.lds SECTIONS { .memory : { . = 0x000000; *(.init); *(.text); *(*); . = ALIGN(4); end = .; } } This assembly code will be executed first because it is mapped first in the memory space through the linker script (firmware.lds). The assembly file defines there is a label main and then starts of with start label.\nThis start function sets all the registers of the processor to 0x0. Next it will load the stack pointer register with 0x0000_4000. Then, the main() function is called. After the main function has finished, an ebreak command is execute which will have the PicoRV32 halt and raise the trap signal.\nWith these 5 files (1 header, 3 C files and a linker script) the final binary file can be generated. This binary is in the Executable and Linkable Format (.elf)\nConversion to human-readable and to FPGA-compatible After running the tool chain, an .elf file is generated. It might become useful to understand what is going on in this file (as humans). Secondly, this file needs to be loaded to the FPGA implementation of the RISC-V.\n\u0026hellip; to human-readable The generated binary file can be disassembled again. Doing this allows us to read what was eventually generated by the compiler. The riscv32-toolbox comes with a program riscv32-unknown-elf-objdump. This can be used to achieve a disassembly by using the -D option.\nAn option to generate this file is present in the Makefile and the result should look something like this.\nfirmware.objdump firmware.elf: file format elf32-littleriscv Disassembly of section .memory: 00000000 \u0026lt;start\u0026gt;: 0:\t00000093 li\tra,0 4:\t00000113 li\tsp,0 8:\t00000193 li\tgp,0 c:\t00000213 li\ttp,0 10:\t00000293 li\tt0,0 14:\t00000313 li\tt1,0 18:\t00000393 li\tt2,0 1c:\t00000413 li\ts0,0 20:\t00000493 li\ts1,0 24:\t00000513 li\ta0,0 28:\t00000593 li\ta1,0 2c:\t00000613 li\ta2,0 30:\t00000693 li\ta3,0 34:\t00000713 li\ta4,0 38:\t00000793 li\ta5,0 3c:\t00000813 li\ta6,0 40:\t00000893 li\ta7,0 44:\t00000913 li\ts2,0 48:\t00000993 li\ts3,0 4c:\t00000a13 li\ts4,0 50:\t00000a93 li\ts5,0 54:\t00000b13 li\ts6,0 58:\t00000b93 li\ts7,0 5c:\t00000c13 li\ts8,0 60:\t00000c93 li\ts9,0 64:\t00000d13 li\ts10,0 68:\t00000d93 li\ts11,0 6c:\t00000e13 li\tt3,0 70:\t00000e93 li\tt4,0 74:\t00000f13 li\tt5,0 78:\t00000f93 li\tt6,0 7c:\t00004137 lui\tsp,0x4 80:\t00010113 mv\tsp,sp 84:\t1c8000ef jal\tra,24c \u0026lt;main\u0026gt; 88:\t00100073 ebreak 0000008c \u0026lt;esns_nop\u0026gt;: 8c:\t00000013 nop 90:\t00008067 ret 00000094 \u0026lt;print_chr\u0026gt;: 94:\t100007b7 lui\ta5,0x10000 98:\t00a7a023 sw\ta0,0(a5) # 10000000 \u0026lt;end+0xffffd98\u0026gt; 9c:\t00008067 ret 000000a0 \u0026lt;print_str\u0026gt;: a0:\t10000737 lui\ta4,0x10000 a4:\t00054783 lbu\ta5,0(a0) a8:\t00079463 bnez\ta5,b0 \u0026lt;print_str+0x10\u0026gt; ac:\t00008067 ret b0:\t00150513 addi\ta0,a0,1 b4:\t00f72023 sw\ta5,0(a4) # 10000000 \u0026lt;end+0xffffd98\u0026gt; b8:\tfedff06f j\ta4 \u0026lt;print_str+0x4\u0026gt; 000000bc \u0026lt;print_dec\u0026gt;: bc:\tfe010113 addi\tsp,sp,-32 # 3fe0 \u0026lt;end+0x3d78\u0026gt; c0:\t00812c23 sw\ts0,24(sp) c4:\t00410413 addi\ts0,sp,4 c8:\t00912a23 sw\ts1,20(sp) cc:\t01212823 sw\ts2,16(sp) d0:\t00112e23 sw\tra,28(sp) d4:\t00050493 mv\ts1,a0 d8:\t00040913 mv\ts2,s0 dc:\t02049c63 bnez\ts1,114 \u0026lt;print_dec+0x58\u0026gt; e0:\t03240a63 beq\ts0,s2,114 \u0026lt;print_dec+0x58\u0026gt; e4:\t10000737 lui\ta4,0x10000 e8:\tfff40413 addi\ts0,s0,-1 ec:\t00044783 lbu\ta5,0(s0) f0:\t03078793 addi\ta5,a5,48 f4:\t00f72023 sw\ta5,0(a4) # 10000000 \u0026lt;end+0xffffd98\u0026gt; f8:\tff2418e3 bne\ts0,s2,e8 \u0026lt;print_dec+0x2c\u0026gt; fc:\t01c12083 lw\tra,28(sp) 100:\t01812403 lw\ts0,24(sp) 104:\t01412483 lw\ts1,20(sp) 108:\t01012903 lw\ts2,16(sp) 10c:\t02010113 addi\tsp,sp,32 110:\t00008067 ret 114:\t00a00593 li\ta1,10 118:\t00048513 mv\ta0,s1 11c:\t0a8000ef jal\tra,1c4 \u0026lt;__umodsi3\u0026gt; 120:\t00140413 addi\ts0,s0,1 124:\tfea40fa3 sb\ta0,-1(s0) 128:\t00a00593 li\ta1,10 12c:\t00048513 mv\ta0,s1 130:\t04c000ef jal\tra,17c \u0026lt;__udivsi3\u0026gt; 134:\t00050493 mv\ts1,a0 138:\tfa5ff06f j\tdc \u0026lt;print_dec+0x20\u0026gt; 0000013c \u0026lt;print_hex\u0026gt;: 13c:\tfff58593 addi\ta1,a1,-1 140:\t00000737 lui\ta4,0x0 144:\t00259593 slli\ta1,a1,0x2 148:\t22870713 addi\ta4,a4,552 # 228 \u0026lt;__modsi3+0x30\u0026gt; 14c:\t100006b7 lui\ta3,0x10000 150:\t0005d463 bgez\ta1,158 \u0026lt;print_hex+0x1c\u0026gt; 154:\t00008067 ret 158:\t00b557b3 srl\ta5,a0,a1 15c:\t00f7f793 andi\ta5,a5,15 160:\t00e787b3 add\ta5,a5,a4 164:\t0007c783 lbu\ta5,0(a5) 168:\tffc58593 addi\ta1,a1,-4 16c:\t00f6a023 sw\ta5,0(a3) # 10000000 \u0026lt;end+0xffffd98\u0026gt; 170:\tfe1ff06f j\t150 \u0026lt;print_hex+0x14\u0026gt; 00000174 \u0026lt;__divsi3\u0026gt;: 174:\t06054063 bltz\ta0,1d4 \u0026lt;__umodsi3+0x10\u0026gt; 178:\t0605c663 bltz\ta1,1e4 \u0026lt;__umodsi3+0x20\u0026gt; 0000017c \u0026lt;__udivsi3\u0026gt;: 17c:\t00058613 mv\ta2,a1 180:\t00050593 mv\ta1,a0 184:\tfff00513 li\ta0,-1 188:\t02060c63 beqz\ta2,1c0 \u0026lt;__udivsi3+0x44\u0026gt; 18c:\t00100693 li\ta3,1 190:\t00b67a63 bgeu\ta2,a1,1a4 \u0026lt;__udivsi3+0x28\u0026gt; 194:\t00c05863 blez\ta2,1a4 \u0026lt;__udivsi3+0x28\u0026gt; 198:\t00161613 slli\ta2,a2,0x1 19c:\t00169693 slli\ta3,a3,0x1 1a0:\tfeb66ae3 bltu\ta2,a1,194 \u0026lt;__udivsi3+0x18\u0026gt; 1a4:\t00000513 li\ta0,0 1a8:\t00c5e663 bltu\ta1,a2,1b4 \u0026lt;__udivsi3+0x38\u0026gt; 1ac:\t40c585b3 sub\ta1,a1,a2 1b0:\t00d56533 or\ta0,a0,a3 1b4:\t0016d693 srli\ta3,a3,0x1 1b8:\t00165613 srli\ta2,a2,0x1 1bc:\tfe0696e3 bnez\ta3,1a8 \u0026lt;__udivsi3+0x2c\u0026gt; 1c0:\t00008067 ret 000001c4 \u0026lt;__umodsi3\u0026gt;: 1c4:\t00008293 mv\tt0,ra 1c8:\tfb5ff0ef jal\tra,17c \u0026lt;__udivsi3\u0026gt; 1cc:\t00058513 mv\ta0,a1 1d0:\t00028067 jr\tt0 1d4:\t40a00533 neg\ta0,a0 1d8:\t0005d863 bgez\ta1,1e8 \u0026lt;__umodsi3+0x24\u0026gt; 1dc:\t40b005b3 neg\ta1,a1 1e0:\tf9dff06f j\t17c \u0026lt;__udivsi3\u0026gt; 1e4:\t40b005b3 neg\ta1,a1 1e8:\t00008293 mv\tt0,ra 1ec:\tf91ff0ef jal\tra,17c \u0026lt;__udivsi3\u0026gt; 1f0:\t40a00533 neg\ta0,a0 1f4:\t00028067 jr\tt0 000001f8 \u0026lt;__modsi3\u0026gt;: 1f8:\t00008293 mv\tt0,ra 1fc:\t0005ca63 bltz\ta1,210 \u0026lt;__modsi3+0x18\u0026gt; 200:\t00054c63 bltz\ta0,218 \u0026lt;__modsi3+0x20\u0026gt; 204:\tf79ff0ef jal\tra,17c \u0026lt;__udivsi3\u0026gt; 208:\t00058513 mv\ta0,a1 20c:\t00028067 jr\tt0 210:\t40b005b3 neg\ta1,a1 214:\tfe0558e3 bgez\ta0,204 \u0026lt;__modsi3+0xc\u0026gt; 218:\t40a00533 neg\ta0,a0 21c:\tf61ff0ef jal\tra,17c \u0026lt;__udivsi3\u0026gt; 220:\t40b00533 neg\ta0,a1 224:\t00028067 jr\tt0 228:\t3130 fld\tfa2,96(a0) 22a:\t3332 fld\tft6,296(sp) 22c:\t3534 fld\tfa3,104(a0) 22e:\t3736 fld\tfa4,360(sp) 230:\t3938 fld\tfa4,112(a0) 232:\t4241 li\ttp,16 234:\t46454443 fmadd.q\tfs0,fa0,ft4,fs0,rmm 238:\t4700 lw\ts0,8(a4) 23a:\t203a4343 fmadd.s\tft6,fs4,ft3,ft4,rmm 23e:\t4728 lw\ta0,72(a4) 240:\t554e lw\ta0,240(sp) 242:\t2029 jal\t24c \u0026lt;main\u0026gt; 244:\t2e38 fld\tfa4,88(a2) 246:\t2e32 fld\tft8,264(sp) 248:\t0030 addi\ta2,sp,8 ... 0000024c \u0026lt;main\u0026gt;: 24c:\t00000537 lui\ta0,0x0 250:\t25850513 addi\ta0,a0,600 # 258 \u0026lt;main+0xc\u0026gt; 254:\te4dff06f j\ta0 \u0026lt;print_str\u0026gt; 258:\t6568 flw\tfa0,76(a0) 25a:\t6c6c flw\tfa1,92(s0) 25c:\t6f77206f j\t73152 \u0026lt;end+0x72eea\u0026gt; 260:\t6c72 flw\tfs8,28(sp) 262:\t0a64 addi\ts1,sp,284 264:\t0000 unimp ... \u0026hellip; to FPGA-compatible Next to \u0026lsquo;decompiling\u0026rsquo; the binary .elf file to a human-readable representation, it can also be translated to a flat text format. This can be achieved with a Python script makehex.py.\nAn option to generate this hex dump is present in the Makefile and the result should look something like this.\nfirmware.hex 00000093 00000113 00000193 00000213 00000293 00000313 00000393 00000413 00000493 00000513 00000593 00000613 00000693 00000713 00000793 00000813 00000893 00000913 00000993 00000a13 00000a93 00000b13 00000b93 00000c13 00000c93 00000d13 00000d93 00000e13 00000e93 00000f13 00000f93 00004137 00010113 1c8000ef 00100073 00000013 00008067 100007b7 00a7a023 00008067 10000737 00054783 00079463 00008067 00150513 00f72023 fedff06f fe010113 00812c23 00410413 00912a23 01212823 00112e23 00050493 00040913 02049c63 03240a63 10000737 fff40413 00044783 03078793 00f72023 ff2418e3 01c12083 01812403 01412483 01012903 02010113 00008067 00a00593 00048513 0a8000ef 00140413 fea40fa3 00a00593 00048513 04c000ef 00050493 fa5ff06f fff58593 00000737 00259593 22870713 100006b7 0005d463 00008067 00b557b3 00f7f793 00e787b3 0007c783 ffc58593 00f6a023 fe1ff06f 06054063 0605c663 00058613 00050593 fff00513 02060c63 00100693 00b67a63 00c05863 00161613 00169693 feb66ae3 00000513 00c5e663 40c585b3 00d56533 0016d693 00165613 fe0696e3 00008067 00008293 fb5ff0ef 00058513 00028067 40a00533 0005d863 40b005b3 f9dff06f 40b005b3 00008293 f91ff0ef 40a00533 00028067 00008293 0005ca63 00054c63 f79ff0ef 00058513 00028067 40b005b3 fe0558e3 40a00533 f61ff0ef 40b00533 00028067 33323130 37363534 42413938 46454443 43434700 4728203a 2029554e 2e322e38 00000030 00000537 25850513 e4dff06f 6c6c6568 6f77206f 0a646c72 00000000 Overall toolflow "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/105_simulation/",
	"title": "105 - Simulation",
	"tags": [],
	"description": "",
	"content": " By now you should have a Vivado project that is able to simulate the PicoRV. Also, you should have a working setup that compiles C-code into a .hex file. It\u0026rsquo;s time to close this loop.\nIn the depicted testbench sits the PicoRV32 in the center. This device-under-test (DUT) is the unmodified code from the PicoRV32 repo.\nAs there currently is no implementation for the memory, the testbench instantiates a model (picorv_mem_model.vhd) that mimics the behaviour of such a memory implementation.\nThis approach is similar to how you modelled a clock source.\nThe picorv_mem_model has an additional input load_file. With this input set, the model reads in a file into it\u0026rsquo;s virtual memory.\nIn the previous section it was discussed how the result of a print function ended up in a write to address 0x10000000. This is also caught by this memory model. Every write to this address hence results in a write to file, e.g. simulation_output.dat.\nBoth the filenames of the input file and the output file are set through generics:\n... picorv_mem_model_inst00: component picorv_mem_model generic map ( G_DATA_WIDTH =\u0026gt; G_DATA_WIDTH, FNAME_HEX =\u0026gt; \u0026#34;/home/jvliegen/vc/github/KULeuven-Diepenbeek/hwswcodedign-course/src/firmware/example1/firmware.hex\u0026#34;, FNAME_OUT =\u0026gt; \u0026#34;/home/jvliegen/vc/github/KULeuven-Diepenbeek/hwswcodedign-course/src/firmware/example1/simulation_output.dat\u0026#34; ) port map ( ... ); ... Please note that the possibility of describing such models is an intrinsic part of the HDL. However, it is still important to understand that this type of code is non-synthesisable, as in \u0026hellip; it can not be translated to hardware components.\nParsing the output A simple Python script is available to \u0026lsquo;parse\u0026rsquo; the output that is generated by the memory model:\npython3 tools/parse_simulation.py \u0026lt;simulation_output_filename\u0026gt;\nThis small script converts the 32-bit binary string to an integer and shows it both decimally and hexa-decimally. Also the corresponding character is printed.\nFeel free to adjust/upgrade/improve/\u0026hellip; this parsing script !!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/106_exercises/",
	"title": "106 - Exercises",
	"tags": [],
	"description": "",
	"content": "Below are a number of programming exercises. The aim is that you 1) prepare a working setup, and 2) that you refresh you low-level C programming skills. In the exercises where inputs are required, these inputs can be hardcoded as we have no means of inputting data to the processor.\nAn example of the file structure can be seen here.\nExercise 101 For this exercise you should simply try to get the examples of this chapter to work.\ncreate a Vivado project import the picorv32.v description import the testbench and the memory model generate the .hex file run the simulation parse the output As FPGA device, you can pick a ZYNQ XC7Z020-1CLG400C. An even better solution is to pick the PYNQ-Z2 board in case you have the board drivers installed. Exercise 102 Complete the print_dec() function.\nExercise 103 Update the simulation so that the output address is 0x8000000.\nExercise 104 Write a firmware function get_hamming_weight() that can calculate the Hamming weight of a value.\nPrint the Hamming weight to the output.\nunsigned int get_hamming_weight(unsigned int x); Determine how long it takes (in clock cycles) to perform the calculation !!\nExercise 105 Write a firmware function get_hamming_distance() that can calculate the Hamming distance between two values.\nPrint the Hamming distance to the output.\nunsigned int get_hamming_distance(unsigned int x, unsigned int y); Determine how long it takes (in clock cycles) to perform the calculation !!\nExercise 106 Write a firmware function get_factorial() that calculates the factorial of an unsigned integer.\nPrint the result to the output.\nunsigned int get_factorial(unsigned int x); Determine how long it takes (in clock cycles) to perform the calculation !!\nExercise 107 Write a firmware function convert() that converts temperature from Fahrenheit to degrees Celsius. The result may be rounded down to approximate the conversion..\nPrint the result to the output.\nunsigned int convert(unsigned int x); Determine how long it takes (in clock cycles) to perform the calculation !!\n(Â F âˆ’ 32) Ã— 5/9 = Â°C e.g. 32Â FÂ =Â 0Â Â°C 86Â FÂ =Â 30Â Â°C\nHanding in exercises When you upload your assigments, check the following: â€¢ all your files are archived in one single file (.zip, .tar, \u0026hellip;) â€¢ structurise your files in subfolders â€¢ firmware/ containing all the software: build files, binaries, \u0026hellip; â€¢ firmware/src/ containing all the source files (.c, .S, \u0026hellip;) â€¢ hdl/ containing all the hardware descriptions (.vhd, .v, .sv, \u0026hellip;) â€¢ hdl/tb/ containing all the simulation files (.vhd) â€¢ files like a README.md, vivado_script.tcl, \u0026hellip; â€¢ README.md: if you want to add some additional info â€¢ vivado.tcl: script to automate project creation in Vivado\nIf you look at the structure of how you need to hand in assignments, you might spot something. These are all plain text files and there are not many of them. However, this will enable you to generate all data you need: binaries, hex-files, vivado projects, bitstreams, \u0026hellip; In case you want to use some version control (like GitHub), it would make sense to track only these files.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/",
	"title": "2  Coprocessor",
	"tags": [],
	"description": "",
	"content": "Coprocessor Image courtesy: Pexels - Pixabay "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/201_coprocessor/",
	"title": "201 - Coprocessor",
	"tags": [],
	"description": "",
	"content": "All the code that you write has to be executed on the processor. With computers being ever more powerful, it is easy to forget about all the work a processor is doing. Irrespective of how simple a job might seem, it still needs to be executed. The example illustrates this. The only thing the processor needs to do is output 2 values. Nonetheless with the software as seen before, this takes 74 clock cycles.\n#include \u0026#34;print.h\u0026#34; void main(void) { print_str(\u0026#34;;\u0026#34;); print_str(\u0026#34;.\u0026#34;); } Offloading When a processor is doing a lot of work, it can become useful if parts of that work could be delegated or offloaded to another processor. Which portions of the work need to be offloaded ? What will the performance gain be ? What is the price (â‚¬s, area in silicon, energy, \u0026hellip; ) ? These are simple questions, but answering them is not straightforward !!\nThe first coprocessors saw the light of day in the 1970\u0026rsquo;s. It became clear that only doing calculations with integer numbers was to restrictive. The first coprocessors were floating-point units (FPUs). These coprocessor were so heavily used that their functionality got integrated in the processor itself.\nMultiplication The PicoRV32 implementation we\u0026rsquo;ve used so far only supports the RV32I instruction set. This means that only the basic integer operations are supported. Although the instruction set does not contain a multiplication operation, it can be used nonetheless.\n#include \u0026#34;print.h\u0026#34; void main(void) { volatile unsigned int value1, value2, product; value1 = 208; value2 = 3; product = value1 * value2; print_dec(product); } Running this C-code generates an output .dat file. After parsing the output looks like this.\n00000000000000000000000000110110 - 054 - 0x36 - 6 00000000000000000000000000110010 - 050 - 0x32 - 2 00000000000000000000000000110100 - 052 - 0x34 - 4 The value 624 is the product of the (hardcoded) values 208 and 3. The reason that this works without having a mul instruction is because of the compiler jumps. The compiler figures out what needs to be done and comes up with a recipe to achieve what the code prescribes.\n00000174 \u0026lt;__mulsi3\u0026gt;: 174:\t00050613 mv\ta2,a0 178:\t00000513 li\ta0,0 17c:\t0015f693 andi\ta3,a1,1 180:\t00068463 beqz\ta3,188 \u0026lt;__mulsi3+0x14\u0026gt; 184:\t00c50533 add\ta0,a0,a2 188:\t0015d593 srli\ta1,a1,0x1 18c:\t00161613 slli\ta2,a2,0x1 190:\tfe0596e3 bnez\ta1,17c \u0026lt;__mulsi3+0x8\u0026gt; 194:\t00008067 ret 00000274 \u0026lt;main\u0026gt;: 274:\tfe010113 addi\tsp,sp,-32 278:\t0d000793 li\ta5,208 27c:\t00f12223 sw\ta5,4(sp) 280:\t00300793 li\ta5,3 284:\t00f12423 sw\ta5,8(sp) 288:\t00412503 lw\ta0,4(sp) 28c:\t00812583 lw\ta1,8(sp) 290:\t00112e23 sw\tra,28(sp) 294:\tee1ff0ef jal\tra,174 \u0026lt;__mulsi3\u0026gt; Changing one letter in the Makefile allows the compiler use the mul instruction.\nARCHITECTURE = rv32i$(subst C,c,$(COMPRESSED_ISA)) to ARCHITECTURE = rv32im$(subst C,c,$(COMPRESSED_ISA)) 00000168 \u0026lt;main\u0026gt;: 168:\tff010113 addi\tsp,sp,-16 16c:\t0d000793 li\ta5,208 170:\t00f12223 sw\ta5,4(sp) 174:\t00300793 li\ta5,3 178:\t00f12423 sw\ta5,8(sp) 17c:\t00412783 lw\ta5,4(sp) 180:\t00812703 lw\ta4,8(sp) 184:\t02e787b3 mul\ta5,a5,a4 188:\t00f12623 sw\ta5,12(sp) 18c:\t00c12503 lw\ta0,12(sp) 190:\t01010113 addi\tsp,sp,16 194:\tf29ff06f j\tbc \u0026lt;print_dec\u0026gt; "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/202_pcpi/",
	"title": "202 - Pico CoProcessor Interface (PCPI)",
	"tags": [],
	"description": "",
	"content": "In Chapter 1 we\u0026rsquo;ve used the PicoRV32 implementation of a RISC-V. This implementation has a number of interfaces to the outside world. The memory interface was already discussed. In this section the Pico CoProcessor Interface (PCPI) is handled.\nMultiplication coprocessor To illustrate (the use of) a coprocessor, let\u0026rsquo;s take the multiplication. In the previous section it is illustrated how the compiler jumped in to achieve multiplication. Depending on the factors, this might take a lot time.\nThe PicoRV32 comes with an example multiplier in hardware. The design is shown in the image below.\nBy now, most of the signals of the PCPI interface should make sense.\nControl path pcpi_valid: a single bit signal that indicates the instruction is valid; pcpi_insn: a 32-bit instruction. This instruction is fetched by the PicoRV32 and handed over to the coprocessor (if needed); pcpi_ready: a single bit signal that indicates the coprocessor is done; pcpi_wait: a single bit signal that indicates the coprocessor needs more time; pcpi_wr: a single bit write enable signal to the PicoRV32. Data path pcpi_rs1: a 32-bit bus containing the first factor; pcpi_rs2: a 32-bit bus containing the second factor; pcpi_rd: a 32-bit bus containing the product; Consulting the readme file of the PicoRV32 learns:\nthe instruction that is implemented through the coprocessor should be non-branching; the pcpi_valid signal only goes on for unsupported instructions; the pcpi_insn, pcpi_rs1 and pcpi_rs2 fields are parsed by the PicoRV32; the PicoRV32 core can optionally decode the pcpi_rd field of the instruction and write the value from pcpi_rd to the respective register. When no external PCPI core acknowledges the instruction within 16 clock cycles, then an illegal instruction exception is raised and the respective interrupt handler is called. A PCPI core that needs more than a couple of cycles to execute an instruction, should assert pcpi_wait as soon as the instruction has been decoded successfully and keep it asserted until it asserts pcpi_ready. This will prevent the PicoRV32 core from raising an illegal instruction exception If all of the above rules are obeyed (which they are in the example), the PicoRV32 can offload all the mul instructions to the coprocessor. This option should be enabled in the PicoRV32 through the parameters: ENABLE_PCPI and ENABLE_MUL.\npicorv32_inst00: component picorv32 generic map( ... ENABLE_PCPI =\u0026gt; \u0026#39;1\u0026#39;, ENABLE_MUL =\u0026gt; \u0026#39;1\u0026#39;, ... Balance Running the code above, with the coprocessor present, gives the same result as the software-only variant. Lucky us !! ðŸ˜ƒ\nWhy should you go for one of both then ? That\u0026rsquo;s an important question and/or decision. To have some arguments in calling the shots, numbers can come in handy.\nsoftware only hardware + software filesize of .elf file (bytes) 5'460 5'068 duration of program (CC) 467 404 required LUTs 897 1'205 required registers 574 868 the software-only version needs more instruction memory. This makes sense as some additional, custom functions are generated to realise the multiplication. the version with the coprocessor finishes the job quicker. the software-only version requires less configurable resources (on FPGA) With these arguments, better-informed decisions can be made.\nIf the available instruction memory is of the utmost importance, some hardware offloading might be useful. For applications where the cost is the most important feature, having fewer hardware coprocessors might be interesting. "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/203_coproccesor_hd/",
	"title": "203 - Coprocessor example",
	"tags": [],
	"description": "",
	"content": "Coprocessor example As an example of a custom coprocessor a hardware component is made for calculating the Hamming distance.\nControl path The control path is made with a set-reset flipflop. The condition for setting is determined by the pcpi_valid signal and the instruction. Only if the opcode in pcpi_insn is 0110011 and the additional opcode field (funct7) is 0000001, this coprocessor is targeted.\nAs long as the set-reset-flipflop is turned on, the coprocessor keeps on working. The data width is set to 32 bits, so after 32 iterations the coprocessor needs to be stopped. This is achieved by having a 32-bit register shifting in zeroes. If only a single 1-bit is present in this register, the reset should be set. This guarantees that the set-reset flipflop will be turned off in the next clock cycle.\nWhile the coprocessor is running, the pcpi_wait signal is kept high. When the set-reset flipflop is reset, one clock cycle later (hence the register) the pcpi_ready and pcpi_wr signal should be high, for one clock period.\nData path Upon activation of the coprocessor both operands pcpi_rs1 and pcpi_rs2 are sampled. While the processor is running, these registers shift their values out. The XOR of both least significant bits serves as an increment signal to a counter register. This total count register is cleared upon activation and is written out through the pcpi_rd bus.\nCheating For this coprocessor to work, a dedicated instruction needs to be defined. Although this certainly is feasible, it is quite a cumbersome job. The compiler needs to be informed of the new instruction, which requires recompiling the cross-compiler.\nOne way to cheat our way around this is to reuse an existing instruction. The drawback of this approach is that this existing instruction can no longer be used with its original functionality.\nThe code below illustrates this cheat by abusing the mul instruction. This was already assumed in the hardware design with parsing the pcpi_insn.\nIn the C-code, an external function is used. This function has two unsigned integers as parameters and also returns an unsigned integer. As this function is not coded in this file, you need to inform the compiler that this function will be found during linking. This is achieved with the extern keyword.\nIn the assembly, the hwswcd_hd() function is programmed. As you can see below, the only instruction this function does is the mul with registers a0 and a1 as operands.\nNote the line .global hwswcd_hd !! This symbol makes sure that the linker can find this function here.\nfirmware.c #include \u0026#34;print.h\u0026#34; extern unsigned int hwswcd_hd(unsigned int value1, unsigned int value2); void main(void) { volatile unsigned int value1, value2, hd; value1 = 5; value2 = 9; hd = hwswcd_hd(value1, value2); print_str(\u0026#34;HD(0x\u0026#34;); print_hex(value1, 2); print_str(\u0026#34;, \u0026#34;); print_hex(value2, 2); print_str(\u0026#34;) = 0x\u0026#34;); print_hex(hd, 2); print_str(\u0026#34;.\u0026#34;); } .section .init .global main .global hwswcd_hd start: /* zero-initialize all registers */ addi x1, zero, 0 addi x2, zero, 0 addi x3, zero, 0 addi x4, zero, 0 addi x5, zero, 0 addi x6, zero, 0 addi x7, zero, 0 addi x8, zero, 0 addi x9, zero, 0 addi x10, zero, 0 addi x11, zero, 0 addi x12, zero, 0 addi x13, zero, 0 addi x14, zero, 0 addi x15, zero, 0 addi x16, zero, 0 addi x17, zero, 0 addi x18, zero, 0 addi x19, zero, 0 addi x20, zero, 0 addi x21, zero, 0 addi x22, zero, 0 addi x23, zero, 0 addi x24, zero, 0 addi x25, zero, 0 addi x26, zero, 0 addi x27, zero, 0 addi x28, zero, 0 addi x29, zero, 0 addi x30, zero, 0 addi x31, zero, 0 /* set stack pointer */ lui sp, %hi(16*1024) addi sp, sp, %lo(16*1024) /* call main */ jal ra, main /* break - trap */ ebreak hwswcd_hd: mul a0, a0, a1 ret Tadaaa You should be able to compile the binary with the code above. Don\u0026rsquo;t forget to target the RISC-V with the multiply extension (add \u0026rsquo;m\u0026rsquo;) The hardware modifications that need to be made are:\ninstantiate the component pcpi_hwswcd_hd (and not the picorv32_pcpi_mul). enable the coprocessor interface ENABLE_PCPI =\u0026gt; '1' enable the multiplication ENABLE_MUL =\u0026gt; '1' 00000000000000000000000001001000 - 072 - 0x48 - H 00000000000000000000000001000100 - 068 - 0x44 - D 00000000000000000000000000101000 - 040 - 0x28 - ( 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000001111000 - 120 - 0x78 - x 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000000110101 - 053 - 0x35 - 5 00000000000000000000000000101100 - 044 - 0x2c - , 00000000000000000000000000100000 - 032 - 0x20 - 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000000111001 - 057 - 0x39 - 9 00000000000000000000000000101001 - 041 - 0x29 - ) 00000000000000000000000000100000 - 032 - 0x20 - 00000000000000000000000000111101 - 061 - 0x3d - = 00000000000000000000000000100000 - 032 - 0x20 - 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000001111000 - 120 - 0x78 - x 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000000110010 - 050 - 0x32 - 2 00000000000000000000000000101110 - 046 - 0x2e - . "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/204_exercises/",
	"title": "204 - Exercises",
	"tags": [],
	"description": "",
	"content": "Exercise 201 Try to get the example for the Hamming distance to work. Make a comparison like the table in 202 where you compare your pure software implementation of the Hamming distance with the codesign.\nExercise 202 Transform the Hamming distance coprocessor to work on the div instruction in stead of the mul instruction.\nExercise 203 Make a new coprocessor that calculates the average of two integer numbers. If the result is non-integer, round it down. For example avg(32,16) = 24 and avg(3,4) = 3. Try to avoid using the pcpi_wait signal.\nCompare a software-only version with a hardware/software codesign of the solution.\nHanding in exercises When you upload your assigments, check the following: â€¢ all your files are archived in one single file (.zip, .tar, \u0026hellip;) â€¢ structurise your files in subfolders â€¢ firmware/ containing all the software: build files, binaries, \u0026hellip; â€¢ firmware/src/ containing all the source files (.c, .S, \u0026hellip;) â€¢ hdl/ containing all the hardware descriptions (.vhd, .v, .sv, \u0026hellip;) â€¢ hdl/tb/ containing all the simulation files (.vhd) â€¢ files like a README.md, vivado_script.tcl, \u0026hellip; â€¢ README.md: if you want to add some additional info â€¢ vivado.tcl: script to automate project creation in Vivado\nIf you look at the structure of how you need to hand in assignments, you might spot something. These are all plain text files and there are not many of them. However, this will enable you to generate all data you need: binaries, hex-files, vivado projects, bitstreams, \u0026hellip; In case you want to use some version control (like GitHub), it would make sense to track only these files.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/",
	"title": "3  System on Chip",
	"tags": [],
	"description": "",
	"content": "System on Chip (SOC) Image courtesy: Pexels - Pixabay "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/301_busarchs/",
	"title": "301 - Bus architectures",
	"tags": [],
	"description": "",
	"content": "A SoC consists of more components than only a processor, as the name already implies. The system has multiple components depending on the task for which it was designed. Having multiple components like timers, interrupt controllers, or communication cores are very useful, unless they can\u0026rsquo;t be used. To achieve reachability, all the components must be connected through some bus architecture to the processor.\nA number of standardised bus architectures exist, for example:\nWishbone Avalon AMBA CoreConnect AMBA ARM has defined an open standard which allows the interconnection of such functional blocks: Advanced Microcontroller Bus Architecture (AMBA). Currently the fifth generation of the AMBA bus is available.\nimage source: https://developer.arm.com/architectures/system-architectures/amba\nIt should not come as a surprise that the more recent versions are more powerful than the older ones, but they are also more complicated ðŸ˜ƒ. When working with design software like Xilinx\u0026rsquo;s Vivado, almost all components have an AXI4 interface. As the provided cores in such an ecosystem are all tuned towards a single standard, it becomes fairly easy for the designer to build a SoC. Two examples of how to use these buses in a system are shown in the images below.\nTo protect ourselves from getting lost in details, only the APB bus will be used in this course. The most recent specification of this protocol can be obtained from the ARM website.\nAdvanced Peripheral Bus (APB) When two components are talking, typically the names master and slave are used. The lingo in the APB-bus uses: the requester and the completer. The image below shows a setup with one requester and one completer. The clock and reset signals are provided externally. Most of the signals are driven by the requester, but (offcourse) a couple of signals are driven by the completer.\nFor a more in-depth description of each of these signals, you can visit the specification.\nTransfers on the APB-bus follow 2 successive phases: the the setup phase and the access phase. In the setup phase the requester drives the SEL and the ADDR lines, amongst other. After one clock cycle the requester drives the ENABLE signal in the access phase.\nWrite transfer (without wait states) Read transfer (without wait states) The examples above show the default write and read transfers. In the specification more detail (and explanation) is available, but putting these images right beside each other allows to better see the differences (and the similarities).\nFrom the images and the description it is clear that each transfer takes at least two clockcycles to complete. There you have the most important reason why the bus is mainly used for peripherals.\nThe peripherals that are connected through the APB bus typically use a register-interface. The idea behind this is that a peripheral has a number of registers that can be written and read by the processor. Based on the address map, read and write operations are handled by the targeted peripheral.\nPeripheral (overhead) Below is an example of a peripheral implementation. It contains NO functional block, but supports an APB interface. In the top-middle part are a number registers. These can be written and read by the requester. As with many other systems, there is a strobe signal. This allows you to mask (out) the 32-bit values with byte granularity.\nThe register in the top-right stores the data that is to be read. This register is loaded with one of the other register OR with another value (depicted by the small cloud in the closing curly bracket).\nAs all the peripherals are connected through a single APB bus, every peripheral must verify if a transfer is to be obeyed or not.\nThis example takes into account the following conditions to determine whether or not a transfer is targeted at this peripheral:\nthe address PADDR is larger than or equal to the base address (BA) the address PADDR is smaller than or equal to the high address (HA) the PSEL input is high the PENABLE input is low (= setup phase) When these conditions are met, the transfer is aimed at this peripheral. Depending on the PWRITE signal, the transfer is either a write (1) or a read (0) transfer.\nThe transfer that is considered for this peripheral (both in case of read or write) is sampled in one of the register on the bottom right. A simple OR of these registers can be used as the PREADY signal.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/302_counter/",
	"title": "302 - Counter peripheral",
	"tags": [],
	"description": "",
	"content": "When a hardware/software codesign is made, we need to be able to measure the performance. A simple way to achieve this, is counting how many clock cycles certain operations take. Later on, this shall be revisited, but the peripheral will be useful (pinky swear).\nHaving arrived at your Master year, a counter is not exactly rocket science, nor brain surgery (lol). The simple design that is shown, is a counter that either be incremented or cleared.\nNote that this is not a special component, but a simple register with a load. The multiplexer and the adder add the functionality of a counter to the register.\nGluing things together The counter that is described above has two 1-bit inputs and one 32-bit output. If we want to control this counter from the processor, these signals should be writeable/readable by the processor. For this the register approach from the previous section is used. One single register is used to \u0026ldquo;direct\u0026rdquo; the functional block. Such a register is often referred to as a command register (CR).\nBy simply wiring (for example) the LSB of REG 0 to the increment input of the counter, a link is made. Similarly the bit at index (1) of REG 0 can be mapped to the clear input. With this configuration, writing to REG 0 controls the counter.\nThe CR could also be read back. This will come in handy. Next to reading the CR, reading back the value of the counter might be useful. Otherwise, the peripheral would be sort-of pointless.\nMemory map In earlier sections the memory was (briefly) discussed. As the SOC uses a 32-bit vector for addresses, this defines the memory space. The lowest addressable memory locations is 0x00000000 (aka zero), while the highest memory location is 0xFFFFFFFF (aka all foxes).\nThere is no doubt that you can write a program that takes 1'073'741'824 instructions (1 billion !!! Mind you, in Dutch this is \u0026ldquo;Ã©Ã©n miljard\u0026rdquo;). With SoCs it would be more realistic if the instruction memory is smaller than 4.3 TeraByte ðŸ˜ƒ. Typically the firmware indeed starts at address 0x0, but it is capped at a maximum.\nTo allow you to write loads of code, it is assumed (for this course) that the instruction memory will never be larger than 0x7FFFFFFF addresses. The remainder of the available memory space is reserved for segmentation.\nThis leaves half of the memory space to allocate as we see fit. As an example the segment for this counter peripheral is placed at address 0x8F000000. In OS-lingo this is called the Base Address (BA). When we assign for example 1024 addresses for the counter, the High Address (HA) is 0x8F000FFF.\nYou might have noticed that the PicoRV32 has a parameter that sets the address of the stack pointer.\nparameter [31:0] STACKADDR = 32\u0026#39;h ffff_ffff With the memory map as described above, simply writing (in software) the value 1 to address 0x81000000, will enable the counter. Writing a value 0, will stop the counter. To clear the value of the counter a value of 2 has to be written to the CR.\nNote that a default write transfer writes 32 bits. Writing a value of 1 to the CR, will not only set the LSB to one, it also sets all other bits to zero !! A default technique to set the bit with index 5 of CR, is to: 1) read the value of CR; 2)apply a mask so the 6th(!) bit is set, and 3) write back the result. This is the reason why it is also useful to be able to read back the value of CR. CR |= (1\u0026laquo;5); /* clearing can we done with: CR \u0026amp;= ~(1\u0026laquo;5); */\nDouble drivers One more thing to point out is double drivers. As you know, every gate can only be driven by a single source. The following scenario can be tempting.\nLet\u0026rsquo;s assume 2 registers for this APB counter functional block. One could be assigned as the CR and the other one can act as a status register (SR). In the example above this could be translate to REG 0 is CR and counter is SR.\nBe aware that the counter cannot be used in the same way as REG 0. It should either be writeable through the APB (or any) bus, or through some other part of the design.\nExample The example below shows a simulation. First, a write of the value 0x1 is done to address 0x81000000. This starts the counter. After a certain amount of time, a write of the value 0x0 is done to the same address. This stops the counter. Finally a read on address 0x81000004 is done to obtain the counter value.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/303_soc/",
	"title": "303 - System on Chip (SoC)",
	"tags": [],
	"description": "",
	"content": "A system on a chip or SoC stands in contrast to the traditional PC or laptop which are organised around a motherboard. In the third Bachelor of this program an entire course was spent on this topic: System-on-Chip design and experimentation. If you need a refresher, please head over to the website.\nThe figure below shows an example of a SoC that we can build with what was seen before. At the hearth of the system is the RISC-V processor (picorv32i). The bus system that connects all the components together is an APB bus. Critical readers might point out the native memory interface of the picorv32i does not fit the APB-bus. A custom adapter is made to make this connection feasible (APB adapter). As you might have already spotted, the picorv32i already comes with two other adapters: 1 for connecting to an AXI bus, and 1 for converting to a wishbone interface.\nThe APB memory and the APB print components were already discussed. It is pointed out once more that both these components are actually models. The HDL code of these components is non-synthesisable, meaning: it\u0026rsquo;s valid HDL code, but it cannot be converted into hardware.\nFinally, the APB counter component was discussed in the previous page, and the APB dummy is simply a placeholder for any other core.\nMemory map One question that is not solved yet is how memory mapped IO (MMIO) is configured. To make live a bit easier (it\u0026rsquo;s already too complicated anyway ðŸ˜‰) the configuration is done in the package: PKG_hwswcodesign.\nPKG_hwswcodesign.vhd ... constant C_BASE_ADDRESS_0 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;00000000\u0026#34;; constant C_HIGH_ADDRESS_0 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;00003FFF\u0026#34;; constant C_BASE_ADDRESS_1 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;80000000\u0026#34;; constant C_HIGH_ADDRESS_1 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;80000004\u0026#34;; constant C_BASE_ADDRESS_2 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81000000\u0026#34;; constant C_HIGH_ADDRESS_2 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81000FFF\u0026#34;; constant C_BASE_ADDRESS_3 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81100000\u0026#34;; constant C_HIGH_ADDRESS_3 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81100FFF\u0026#34;; ... firmware.lds SECTIONS { .memory : { . = 0x000000; *(.init); *(.text); *(*); . = ALIGN(4); end = .; } } These constants set both the base address and the high address of the four components. Which values you choose here, is completely up to you. One traditional technique is to have the memory start at 0x0. This is also reflected in the linker-script (firmware.lds).\nEvery component gets its base address (BA) and high address (HA) configured through generics (or parameters for you .v people). The component can/could/should/may/\u0026hellip; check these limits to see whether or not communication is intended for them. The APB bus also checks this to determine if the component needs to be talked to or not. Don\u0026rsquo;t forget to make the correct modification on ALL (package, component, and APB-bus) locations if you want to modify the memory map.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/304_exercises/",
	"title": "304 - Exercises",
	"tags": [],
	"description": "",
	"content": "Exercise 301 Try to get the example for the counter-enforced SoC to work.\nExercise 302 Make a new (as in: don\u0026rsquo;t modify the dummy) component that can calculated the Hamming distance of two values. Make a comparison like the table in 202 where you compare your pure software implementation of the Hamming distance with the codesign.\nExercise 303 Make a new component that calculates the sine of a positive angle. The angle is provided as natural number (no decimals), in degrees and can be up to 10 bits. To prevent decimal numbers, the resulting value should be multiplied with 1'000'000. The remaining decimal digits can be dropped. Hence the result should fit in 20 bits. Negative numbers should be represented in two\u0026rsquo;s complement.\nSome examples: PROTIP: work smart, not hard !! Exercise 304 Make a new component that can calculated at matrix multiplication. This is (one of) the core operattion(s) in machine learning. Not to complicate things too much: 1) only the matrix multiplication of two 2x2 matrices should be made; 2) the elements are 8-bit in size; and 3) the multiplication should be modulo 256 (as in, only take the 8 least significant bits of the product).\nFor those who don\u0026rsquo;t remember how matrix multiplicatiork, it goes like this.\nMake a comparison like the table in 202 where you compared your pure software implementation of the Hamming distance with the codesign. Handing in exercises When you upload your assigments, check the following: â€¢ all your files are archived in one single file (.zip, .tar, \u0026hellip;) â€¢ structurise your files in subfolders â€¢ firmware/ containing all the software: build files, binaries, \u0026hellip; â€¢ firmware/src/ containing all the source files (.c, .S, \u0026hellip;) â€¢ hdl/ containing all the hardware descriptions (.vhd, .v, .sv, \u0026hellip;) â€¢ hdl/tb/ containing all the simulation files (.vhd) â€¢ files like a README.md, vivado_script.tcl, \u0026hellip; â€¢ README.md: if you want to add some additional info â€¢ vivado.tcl: script to automate project creation in Vivado\nIf you look at the structure of how you need to hand in assignments, you might spot something. These are all plain text files and there are not many of them. However, this will enable you to generate all data you need: binaries, hex-files, vivado projects, bitstreams, \u0026hellip; In case you want to use some version control (like GitHub), it would make sense to track only these files.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/",
	"title": "4  Interrupt",
	"tags": [],
	"description": "",
	"content": "Interrupt Image courtesy: Pexels - Pavel Danilyuk "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/401_interrupt/",
	"title": "401 - Interrupt",
	"tags": [],
	"description": "",
	"content": "In the beginning of the processor-age, all software was bare metal. This means that the processor is simply executing instructions, directly on the hardware. In contrast to bare metal, most computers nowadays run an operating system. However, many microcontrollers still run bare-metal-code. Everything that we have been doing, was bare metal, too.\nMultiple tasks When operating without an OS, it becomes more difficult to run multiple tasks. Let\u0026rsquo;s take the example of a UART, aka the serial port. Imagine a program is running and it has to change a parameter that is fed to program over UART.\nPolling The simplest way would be to periodically check if there is a command. Periodically checking for a condition is called polling.\nIn this example, the main loop is running forever. The program conditionally takes one of two paths (an if-statement). In the left-hand branch, there is a repetition (a for or while loop). Finally, there is one more statement.\nDepending on the fact whether or not there is a new command, the left or right path is taken to the start of the loop again. Let\u0026rsquo;s say that, in case of a new command, the 3 yellow statements have to be executed.\nAlthough polling provides a working solution, it\u0026rsquo;s not the best solution. There is a additional delay (in this case of 1 if-statement), if a command arrives right after the checking, it has to wait for the next iteration, \u0026hellip;\nInterrupts In 1953 (!) the first interrupt-powered computer was invented. An interrupt does exactly what it is named after. It interrupts the current flow of the processor. A good analogy is the raising of a finger, in class.\nThe example above would just keep on executing the main loop. Irrespective of when the UART comes now, this main loop is interrupted. After interruption, the three yellow statements are executed. Finally, the main loop is resumed at the point where it was left.\nAs long as there are no interrupt storms, the impact of interrupts is low. They are still used in modern systems and the typical use-cases are asynchronous communication systems, like network cards, mouse movements, timers, or keyboard-key presses.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/402_handling/",
	"title": "402 - Interrupt handling",
	"tags": [],
	"description": "",
	"content": "Interrupts can be generated by both hardware and software, but hardware-interrupts are focussed on here. A processor typically has a number of hardware interrupts. These signals are connected to the cores that generate interrupts.\nWhen a core wants to signal an interruption, it raises the signal. This is called an Interrupt Request (IRQ). The processor has to halt its operation, to the interrupt can be handled. However, the processor has a context. There are values in the registers and the stack pointer and program counter are set to a certain value. Before the processor can drop what it\u0026rsquo;s doing, a backup of this context has to be made.\nAfter backing up the context, the processor runs some software code that handles the IRQ. This small piece of software code is the interrupt handler or interrupt service routine (ISR). It\u0026rsquo;s trivial that, after the execution of the ISR, the backed-up context needs to be restored.\nInterrupt service routines should not take too long to run. After all, the complete system is waiting for it\u0026rsquo;s end, before it can continue.\nFor the sake of completeness it is mentioned that interrupts can also be nested, as in: an interrupt during the execution of an ISR. Typically, there is a hierarchy that decides which IRQ has priority.\nInterrupts and PicoRV32 The RISC-V implementation of the PicoRV32 allows the usage of interrupts, albeit not entirely according to the RISC-V specifications.\nThe IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification. Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.\nTo use interrupts with the PicoRV32, the generic ENABLE_IRQ needs to be enabled. This enables the use of the 32-bit irq input that provides the IRQs. When an interrupt is getting handled, the PicoRV32 signals this by raising the corresponding eoi (end of interrupt) signal. When the interrupt is handled, this signal is dropped.\nThis all looks nice-and-simple, but there are quite some things going on under the hood.\nWhere to start (with our implementation)? The first parameter we can look at is where to processor starts running code. Until now, the objectdump look something like shown here. At address 0x00000000 the initialisationÂ was done. This code came from the start.S file and it initialises all 32 register to 0x0, sets the stack pointer (sp), and jumps to the main function.\nSubsequently, the functionsÂ are place in the memory space. Every function that is required in the program is put sequentially.\nFinally, the mainÂ function is positioned. Typically, the main function never exits. There some outer loop that keeps on running. In case the main function would exit, the processor goes back to which ever function called the main function. In our case, this is the start. The only thing the start does, in this case, is stopping the processor with the ebreak command.\nAt the highest address (of the allocated memory space) the stack is put. As a reminder, the stack grow in the opposite direction, when required.\nWhen adding the interrupt functionality we have to define some more sections.\nThe start of the program is placed in the reset vectorÂ . This section acts a sort of boot-loader. The absolute minimum of settings is done, after which a jump to the startÂ is made. A frequently used technique is restrict the size of the reset_vector. This ensures that the next section (the interrupt vector) can start at a fixed memory position, irrespective of the length of the start.\nThe interrupt handlerÂ section holds the assembly-code that is responsible for the backing-up and restoring of the context. Of course, between the backup and restore of the context, the interrupt service routine should be called. Another sections that has to be defined is that of the location where the context may be stored: interrupt registersÂ .\nFinally, also the interrupt handling can make use of a stack. This interrupt stackÂ is independent of the normal stack.\nNote that the addition of these sections, doesn\u0026rsquo;t affect the mainÂ other than a relocation of its starting address.\nHow to reach? As can be seen from the image above, there is one arrow that connects the left hand portion to the right hand portion. With this observation, it can be asked HOW the processor switches back from right to left? The component that takes care of this is processor itself. There has to be some hardware block that allow for interrupts. If an irq arrives, the program counter is automatically set the interrupt vector.\nYou might have already noticed when instantiating the PicoRV32, there are some generics/parameters that have to be set. The PROGADDR_RESET is a 32-bit vector that defines the address at which the processor has to start running, after reset: the reset vectorÂ . In the example above, this is kept at the default: 0x00000000. Next there is the PROGADDR_IRQ which is a 32-bit vector that defines the start address of the interrupt handlerÂ . This, also, is kept at its default value: 0x00000010.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/403_example/",
	"title": "403 - Example",
	"tags": [],
	"description": "",
	"content": "This page gives a hands-on example of using interrupts with the PicoRV32.\nHARDWARE RISC-V instantiation At the instantiation, the following additional mappings need to be made:\nENABLE_IRQ \u0026hellip; to \u0026lsquo;1\u0026rsquo; ENABLE_IRQ_QREGS \u0026hellip; to \u0026lsquo;1\u0026rsquo; ENABLE_IRQ_TIMER \u0026hellip; to \u0026lsquo;1\u0026rsquo; MASKED_IRQ \u0026hellip; to x\u0026quot;00000000\u0026quot; LATCHED_IRQ \u0026hellip; to x\u0026quot;FFFFFFFF\u0026quot; PROGADDR_RESET \u0026hellip; to x\u0026quot;00000000\u0026quot; PROGADDR_IRQ \u0026hellip; to x\u0026quot;00000010\u0026quot; These settings:\nenable the IRQ ensures the IRQs are not masked-out set the reset vector set the IRQ handler Interrupts can be given through signal irq, and the ack\u0026rsquo;s come at the eoi signal.\nSOFTWARE PicoRV32 custom instructions The PicoRV32 has a handful of custom instructions. To make the assembly-code (a bit) more readable some custom instructions and register-names have been defined. These can be found in custom_ops.S from the PicoRV32 Github repository.\npicorv32_getq_insn(): copy q-register to gp-register picorv32_setq_insn(): copy gp-register to q-register picorv32_retirq_insn(): return from interrupt and re-enable interrupts picorv32_maskirq_insn(): write a new value to the irq mask register and reads the old value (The \u0026ldquo;IRQ Mask\u0026rdquo; register contains a bitmask of masked (disabled) interrupts). picorv32_waitirq_insn(): pause execution until an interrupt becomes pending picorv32_timer_insn(): reset the timer counter to a new value. More info here.\nReset vector The start.S assembly file that has been used up until now, needs to be extended.\nreset_vec: // no more than 16 bytes here ! // enable all interrupts picorv32_maskirq_insn(zero, zero) // jump to start function j start The reset vector can not contain more than 16 instructions. Otherwise, exceeding the 0x10 offset of the PROGADDR_IRQ, will overwrite the IRQ vector. All the interrupts are enabled (by setting their mask-value to zero). A jump to startÂ is made. Interrupt handler The start.S assembly file that has been used up until now, needs to be extended some more.\n.balign 16 irq_vec: /* save registers, by copying through x1 and x2 */ picorv32_setq_insn(q2, x1) picorv32_setq_insn(q3, x2) lui x1, %hi(irq_regs) addi x1, x1, %lo(irq_regs) picorv32_getq_insn(x2, q0) sw x2, 0*4(x1) picorv32_getq_insn(x2, q2) sw x2, 1*4(x1) picorv32_getq_insn(x2, q3) sw x2, 2*4(x1) sw x3, 3*4(x1) sw x4, 4*4(x1) sw x5, 5*4(x1) sw x6, 6*4(x1) sw x7, 7*4(x1) sw x8, 8*4(x1) sw x9, 9*4(x1) sw x10, 10*4(x1) sw x11, 11*4(x1) sw x12, 12*4(x1) sw x13, 13*4(x1) sw x14, 14*4(x1) sw x15, 15*4(x1) sw x16, 16*4(x1) sw x17, 17*4(x1) sw x18, 18*4(x1) sw x19, 19*4(x1) sw x20, 20*4(x1) sw x21, 21*4(x1) sw x22, 22*4(x1) sw x23, 23*4(x1) sw x24, 24*4(x1) sw x25, 25*4(x1) sw x26, 26*4(x1) sw x27, 27*4(x1) sw x28, 28*4(x1) sw x29, 29*4(x1) sw x30, 30*4(x1) sw x31, 31*4(x1) /* call interrupt handler C function */ lui sp, %hi(irq_stack) addi sp, sp, %lo(irq_stack) /* arg0 = address of regs */ lui a0, %hi(irq_regs) addi a0, a0, %lo(irq_regs) /* arg1 = interrupt type */ picorv32_getq_insn(a1, q1) /* call to C function */ jal ra, irq /* restore registers */ /* new irq_regs address returned from C code in a0 */ addi x1, a0, 0 lw x2, 0*4(x1) picorv32_setq_insn(q0, x2) lw x2, 1*4(x1) picorv32_setq_insn(q1, x2) lw x2, 2*4(x1) picorv32_setq_insn(q2, x2) lw x3, 3*4(x1) lw x4, 4*4(x1) lw x5, 5*4(x1) lw x6, 6*4(x1) lw x7, 7*4(x1) lw x8, 8*4(x1) lw x9, 9*4(x1) lw x10, 10*4(x1) lw x11, 11*4(x1) lw x12, 12*4(x1) lw x13, 13*4(x1) lw x14, 14*4(x1) lw x15, 15*4(x1) lw x16, 16*4(x1) lw x17, 17*4(x1) lw x18, 18*4(x1) lw x19, 19*4(x1) lw x20, 20*4(x1) lw x21, 21*4(x1) lw x22, 22*4(x1) lw x23, 23*4(x1) lw x24, 24*4(x1) lw x25, 25*4(x1) lw x26, 26*4(x1) lw x27, 27*4(x1) lw x28, 28*4(x1) lw x29, 29*4(x1) lw x30, 30*4(x1) lw x31, 31*4(x1) picorv32_getq_insn(x1, q1) picorv32_getq_insn(x2, q2) picorv32_retirq_insn() As a reminder:\nregister x0 contains a hard-wired value of 0x00000000 register x1 contains the return address register x2 contains the stack pointer (sp) register x3 is for general purpose (gp) register x4 contains the thread pointer (tp) First of all, it has to be made sure that the interrupt handler starts at address 0x00000010. This can be done with .balign 16.\nNext, the copying of the state has to be done. All the copies need to be made to the interrupt registersÂ . This happens in these steps:\nbackup of registers x1 and x2 backup registers x1 and x2 to q2 and q3 load the address of interrupt registersÂ in x1 copy registers q0, q2 and q3 to interrupt registersÂ by using relative addressing (offsets against the value that is stored in x1), through x2 backup of registers x3 .. x31 copy the registers to interrupt registersÂ by using relative addressing (offsets against the value that is stored in x1), through x2 When everything is safely backed up, it\u0026rsquo;s time to call the actual instructions for handling the interrupt. This is a C-function:\nuint32_t *irq(uint32_t *regs, uint32_t irqs) Before a call to this function can be made, the stack pointer (sp) is changed to use the interrupt stackÂ .\nThe two arguments that are passed to the irq function need to be stored in a0 and a1. These arguments are set, prior to performing the jump-and-link to the actual function.\nThe restore of the state is done in a similar fashion as the backup. When everything is tidied up, the \u0026lsquo;return-from-interrupt\u0026rsquo; function is called: picorv32_retirq_insn().\nThe actual C-code for the interrupt handler can be downloaded from the PicoRV32 Github repository (irq.c).\nInterrupt registers irq_regs: // registers are saved to this memory region during interrupt handling // the program counter is saved as register 0 .fill 32,4 Interrupt stack // stack for the interrupt handler .fill 128,4 irq_stack: Simulation With these modifications to hardware and software, the simulation should be able to show the working, interrupt-able processor.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/404_exercises/",
	"title": "404 - Exercises",
	"tags": [],
	"description": "",
	"content": "Exercise 401 Try to get the example to work.\nExercise 402 Determine how much time it takes for handling a single interrupt.\nExercise 403 Start from the example of the counter in 302. Have the peripheral trigger an interrupt when the count reaches 100'000'000. Given that a clock cycle takes 10 ns. an interrupt should be triggered every (10 ns/CC x 100'000'000 CC) second. Meanwhile the processor is in an endless loop that prints something. When the interrupt comes, handle it accordingly and reset the counter.\nHanding in exercises When you upload your assigments, check the following: â€¢ all your files are archived in one single file (.zip, .tar, \u0026hellip;) â€¢ structurise your files in subfolders â€¢ firmware/ containing all the software: build files, binaries, \u0026hellip; â€¢ firmware/src/ containing all the source files (.c, .S, \u0026hellip;) â€¢ hdl/ containing all the hardware descriptions (.vhd, .v, .sv, \u0026hellip;) â€¢ hdl/tb/ containing all the simulation files (.vhd) â€¢ files like a README.md, vivado_script.tcl, \u0026hellip; â€¢ README.md: if you want to add some additional info â€¢ vivado.tcl: script to automate project creation in Vivado\nIf you look at the structure of how you need to hand in assignments, you might spot something. These are all plain text files and there are not many of them. However, this will enable you to generate all data you need: binaries, hex-files, vivado projects, bitstreams, \u0026hellip; In case you want to use some version control (like GitHub), it would make sense to track only these files.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_qoi/",
	"title": "5 QOI",
	"tags": [],
	"description": "",
	"content": "Quite OK Image (QOI) "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_qoi/501_digital_image/",
	"title": "501 Digital image",
	"tags": [],
	"description": "",
	"content": "Images are everywhere. When looking at digital images (as in: not for printing) every pixel of the image has pixelvalue. Typically, the light that is generated in a pixel is composed of red light, green light, and blue light, hence RGB. To make photos or movies, some device needs to capture the light. This is done in an image sensor. For the sake of completeness, it is mentioned that there two main types of sensors: CCD and CMOS.\nThese sensors have receptors that record the light. The output of the sensor consists of values how much R, G, and B light is measured. This results in RGB values for each pixel. The more pixels that are available, the better the quality of the image is. In the figure, the left side has a 12 by 9 resolution and the right has a 24 by 18 resolution.\nIf we do some quick math, we come to the following.\nlet\u0026rsquo;s assume each R, G, and B value is represented in a single byte every pixel, hence, is 3x1 byte = 3 bytes the left resolution has 12x9 = 108 pixels the right resolution has 24x18= 432 pixels the left image thus has 108 pixels x 3byte/pixel = 324 bytes the right image thus has 108 pixels x 3byte/pixel = 1296 bytes It is not hard to see that the larger the resolution, the more bytes are required to store the images.\nColor depth In the example above, it was assumed that every pixel is stored in 3 bytes, one for each color. This boils down to 24 bits per pixel (bpp). This is known as True color and, as of 2018, this is used by most phone displays and computers. With true color, 224 colors can be displayed, or 16'777'216 colors.\nThe alpha channel In computer graphics, it is sometimes desireable to have a transparent background. Since the late 1970\u0026rsquo;s there is the concept of an alpha channel. This is a value that indicates how opaque a pixel is: entirely transparent (0) or entirely opaque (1). This alpha value is also stored with the R, G, and B values of the pixel. Up until now, a single pixel used 24 bits. With the addition of an 8-bit alpha channel, the total number of bits per pixels is 32. Cool, a power of 2 ðŸ˜ƒ\nResolutions The images above serve to illustrate the concept of pixels and resolutions. Of course there are predefined resolutions. Some of the most well known resoltions (width x height) are listed here:\nSD, also known as 480p, has a dimension of 640x480 HD, also known as 720p, has a dimension of 1280x720 Full HD, also known as 1080p, has a dimension of 1920x1080 Quad HD, also known as 2K, has a dimension of 2560x1440 Ultra HD, also known as 4K, has a dimension of 4096x2160 Full Ultra HD, also known as 8K, has a dimension of 7680x4320 This table calculates how many bytes are required to store an image of a certain resolution, given that every pixel is represented by 4 bytes. Take a look at that Full Ultra HD file: 132'710'400 bytes. That is 132 MB!!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_qoi/502_image_formats/",
	"title": "502 Image formats",
	"tags": [],
	"description": "",
	"content": "In general, to store a file on a computer, some form for file format is required. Examples of fileformats are: .pdf, .docx, and .html. A file format defines an encoding protocol on how to store the data.\nAs just seen, storing images in full will require a lot of storage. Of course, there are file formats for images as well. The most well known image file formats (or image formats) are .jpeg, .png, and .gif. If no encoding is used (or not much), this type of file format is referred to as a raw image.\nImage encoding formats \u0026hellip; this is where it gets insane. Some formats are small, others are high-quality. Some formats drop certain data (lossy), others keep everything (lossless). Some formats are used by camera\u0026rsquo;s that generate images, others are generated by artists. Some formats are intended for the web, others are specially for printing \u0026hellip; you get the point ðŸ˜‰\nImage by Jon Sneyers - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=126783849 QOI For the project, the QOI (Quite OK Image Format) will be used. More info can be found here. QOI\u0026rsquo;s specification can be found here and was released on January 2022, by Dominic Szablewski, who claims:\n\u0026ldquo;I have no idea what i\u0026rsquo;m doing. I\u0026rsquo;m not a compression guy.\u0026rdquo;\nQOI starts by noting down a header which consists of a handfull of parameters. Next, there is an indetermined number of chunks. And finally, there is fixed 8-byt end marker.\nThe chunks in between the header and end marker can be of these 5 types:\nRUN chunk: a run of repeating pixels INDEX chunk: an index to a recently seen pixel DIFF chunk: difference to the previous pixel LUMA chunk: difference to the previous pixel\u0026rsquo;s green value RGB chunk: full pixel value RGBA chunk: full pixel value with alpha The order in which the chunks are enumerated, is also the order of precedence.\nFor the indexed chunk, a running array is kept of 64 pixels. If the current pixel is present in this array, the position in the array is stored. QOI uses a quick way for looking up the pixel by means a hash table. A custom, very simple hash function is designed for this purpose:\nH(r, g, b, a) = (3xr + 5xg +7xb + 11xa) mod 64\nIf the array has the same pixel value on the position as pointed to by the hash, the INDEX chunk is used.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_qoi/503_example/",
	"title": "503 Example",
	"tags": [],
	"description": "",
	"content": "Here, an example is shown to help you understand how QOI (encoding) works. The data from the 8-by-8 sensor looks like shown below.\nHeader The header is stictly defined:\nThe first for bytes are the letters \u0026lsquo;q\u0026rsquo;, \u0026lsquo;o\u0026rsquo;, \u0026lsquo;i\u0026rsquo;, and \u0026lsquo;f\u0026rsquo;. These letters have to be UTF-8 encoded first, which results in 0x716F6966. The width of the image is stored as a 32-bit value: 0x00000008. The height of the image is stored as a 32-bit value: 0x00000008. Depending on whether or not an alpha channel is present, the number of channels is either 3 (for RGB) or 4 (for RGBA). This is stored in a single byte: 0x03. The colorspace is also represented in a single byte: 0x00 for sRGB with linear alpha and 0x01 for an image where all channels are linear. This makes the encoding of the header equal to 0x716F696600000008000000080300 . Now we continue with the second row.\nBoth the channels and the colorspace fields are puely informative.\nChunks At the start, we assume that the previous values of R, G, and B (called R_d, G_d, and B_d) are all 0x0. The previous value for alpha (A_d) is 0xFF. The running array (RA) of width 64 is initialised on 0x0\u0026rsquo;s. The current longest runs of repeating pixels is also initialised on -1 (RLE).\nThe pixel at (0,0) has value 0xFF0000FF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d 2)Â It is not present in the RA. Nonetheless, we add it. H(R,G,B,A) = 50, so RA[50] = 0xFF0000FF. 3)Â Difference with previous pixels dr = 0xFF - 0x00 = 0xFF (= -1) =\u0026gt; b01 dg = 0x00 - 0x00 = 0x00 (= 0) =\u0026gt; b10 db = 0x00 - 0x00 = 0x00 (= 0) =\u0026gt; b10 This chunk is hence encoded as b01 b01 b10 b10 = b01011010 = 0x5A . R_d becomes 0xFF, G_d becomes 0x00, B_d becomes 0x00, A_d remains 0xFF.\nThe pixel at (1,0) has value 0xFF0000FF\n1)Â It is the same as the previous values R_d, G_d, B_d and A_d, so this is run-length encoding. RLE=0\nThe pixel at (2,0) has value 0xFF0000FF\n1)Â It is the same as the previous values R_d, G_d, B_d and A_d, so this is run-length encoding. RLE=1\nThe pixel at (3,0) has value 0xFF0000FF\n1)Â It is the same as the previous values R_d, G_d, B_d and A_d, so this is run-length encoding. RLE=2\nThe pixel at (4,0) has value 0x00FF00FF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d. As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is not present in the RA. Nonetheless, we add it. H(R,G,B,A) = 45, so RA[48] = 0x00FF00FF. 3)Â Difference with previous pixels dr = 0x00 - 0xFF = 0x01 (= 1) =\u0026gt; b11 dg = 0xFF - 0x00 = 0xFF (= -1) =\u0026gt; b01 db = 0x00 - 0x00 = 0x00 (= 0) =\u0026gt; b10 This chunk is hence encoded as b01 b11 b01 b10 = b01110110 = 0x76 . R_d becomes 0xFF, G_d becomes 0x00, B_d becomes 0x00, A_d remains 0xFF.\nThe pixel (5,0), (6,0), and (7,0) are handled similarly to (1,0), (2,0), and (3,0).\n1)Â It is the same as the previous values R_d, G_d, B_d and A_d, so this is run-length encoding. RLE=0, RLE=1, RLE=2\nThis makes the encoding of the first row, currently, equal to 0x5AC276 . Now we continue with the second row.\nThe pixel at (0,1) has value 0xFF0000FF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d. As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is present in the RA. H(R,G,B,A) = 50, and RA[50] == 0xFF0000FF. This chunk is hence encoded as b00 b110010 = b00110010 = 0x32 .\nThe pixels at (1,1), (2,1), and (3,1) are handled similar as before.\nThe pixel at (4,1) has value 0x00FF00FF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d. As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is present in the RA. H(R,G,B,A) = 48, and RA[48] == 0x00FF00FF. This chunk is hence encoded as b00 b110000 = b00110000 = 0x30 .\nThe pixels at (5,1), (6,1), and (7,1) are handled similar as before.\nThis makes the encoding of the second row, currently, equal to 0xC232C230 .\nThe third and fourth row in the image are handled identically to row 2. This makes the encoding of these rows, currently, equal to 0xC232C2300xC232C230 .\nThe pixel at (0,4) has value 0x0000FFFF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is not present in the RA. Nonetheless, we add it. H(R,G,B,A) = 46, so RA[46] = 0x0000FFFF. 3)Â Difference with previous pixels dr = 0x00 - 0x00 = 0x00 (= 0) =\u0026gt; b10 dg = 0x00 - 0xFF = 0x01 (= 1) =\u0026gt; b11 db = 0xFF - 0x00 = 0x00 (= -1) =\u0026gt; b01 This chunk is hence encoded as b01 b10 b11 b01 = b01101101 = 0x6D .\nThe pixels at (1,4), (2,4), and (3,4) are handled similar as before.\nThe pixel at (4,4) has value 0x7F7F7FFF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is not present in the RA. Nonetheless, we add it. H(R,G,B,A) = 38, so RA[38] = 0x7F7F7FFF. 3)Â Difference with previous pixels dr = 0x7F - 0x00 = 0x7F =\u0026gt; not defined dg = 0x7F - 0x00 = 0x7F =\u0026gt; not defined db = 0x7F - 0xFF = 0x80 =\u0026gt; not defined 4)Â Difference with previous pixel\u0026rsquo;s green dg = 0x7F - 0x00 = 0x7F =\u0026gt; not defined \u0026hellip; 5)Â RGB A_d and a are equal =\u0026gt; b11111110 x7F x7F x7F This chunk is hence encoded as 0xFE7F7F7F .\nThe pixels at (5,4), (6,4), and (7,4) are handled similar as before.\nThis makes the encoding of the fifth row, currently, equal to 0xC26DC2FE7F7F7F .\nThe pixel at (0,5) has value 0x0000FFFF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is present in the RA. H(R,G,B,A) = 46, and RA[46] == 0x0000FFFF. This chunk is hence encoded as b00 b101110 = b00101110 = 0x2E .\nThe pixels at (1,5), (2,5), and (3,5) are handled similar as before.\nThe pixel at (4,5) has value 0x7F7F7FFF\n1)Â It is not the same as the previous values R_d, G_d, B_d and A_d As there was a run length ongoing, this has to be recorded. The chunks becomes: b11 b000010 = b11000010 = 0xC2 . RLE is reset to -1. 2)Â It is present in the RA. H(R,G,B,A) = 38, and RA[38] == 0x7F7F7FFF. This chunk is hence encoded as b00 b100110 = b00100110 = 0x26 .\nThe pixels at (5,5), (6,5), and (7,5) are handled similar as before.\nThis makes the encoding of the fifth row, currently, equal to 0xC22EC226 .\nThe final 2 rows are similarly processed as the previous one making the enconding equal to 0xC22EC226C22EC226 .\nBEWARE!! There is still something in the RLE!! This is however handled equally as above. This means another, final, 0xC2 needs to be added.\nEnd marking The end marker is a fixed 8-byte value: 0x0000000000000001 .\nResults of the example The result of the QOI encoding of the image above hence is:\n0x716F696600000008000000080300 0x5AC276 0xC232C230 0xC232C230 0xC232C230 0xC26DC2FE7F7F7F 0xC22EC226 0xC22EC226C22EC226 0xC2 0x0000000000000001Â 716F6966000000080000000803005AC276C232C230C232C230C232C230C26DC2FE7F7F7FC22EC226C22EC226C22EC226C20000000000000001Â This encoded result has a total size of 57 bytes. If all the 64 pixels (8 by 8) would have to be stored in raw data, with an alpha channel, this would result in 256 bytes. Without an alpha channel, this would result in 192 bytes which is a reduction of 70%!!\nIf we assume that 1 image is to be recorded every 40 ms, this would result in 25 images per second. This is approximately the framerate of video. If the sensor would make one image every 40 ms, it also has to be encoded on that speed. In the simulation, as shown below, the encoding of a single image roughly takes 190000 ns. If we extrapolate this result, we get: 190000 ns / 64 pixels = 2.97 Âµs per pixel, and thus a 480p image would take 640*480*3 Âµs = 307200*3 Âµs = 912384 Âµs = 912.4 ms.\n\u0026hellip; and this is an extrapolation!!\nIt is hard to give a fixed duration for the encoding of single image. An image of 307'200 consecutive white pixels will be done more quickly than 307'200 random pixels.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_qoi/504_project/",
	"title": "504 Project",
	"tags": [],
	"description": "",
	"content": "The project within this course will have you designing an SOC that encodes sensor data to a QOI encoded image. As it would not be realistic to build the entire system, a number of compents will only be simulated:\nAPB_mem_model: this is model for the memory containing the instructions and data APB_print_model: this is model for the SD-card storage. For the sake of simplicity, it is assumed that all writes to 0x8000000 will automatically be handled. This is similar as the print model that was seen earlier. APB_sensor_model: this model simulates the camera. When an image is taken, it is stored in RAW format. The sensor autonomously stores its data starting from 0x40000008 onwards. On 0x40000000 the sensor writes the width of the image and on 0x40000004 the height is written. Goals This project is to be achieved in two steps:\na software-only version, and a HW/SW codesign. This first version (SW-only) will set the playing level. Additionally, this will help you in understanding the encoding scheme. The result of the first version will be a working implementation. This will allow you to run the numbers (latency, resource usage, throughput, \u0026hellip;).\nWhen the first version is done, you choose which optimisations you\u0026rsquo;re going to make. After these optimisations are approved, you\u0026rsquo;ll set of to make the HW/SW codesign. You can use which ever technique you think is best for obtaining your optimisations.\nBelow you can find a number of resources that might come in handy.\nResources Link to the QOI specification Example image in: \u0026amp;lsquo;sensor-data-format\u0026amp;rsquo;, png, and in qoi Handing in exercises When you upload your assigments, check the following: â€¢ all your files are archived in one single file (.zip, .tar, \u0026hellip;) â€¢ structurise your files in subfolders â€¢ firmware/ containing all the software: build files, binaries, \u0026hellip; â€¢ firmware/src/ containing all the source files (.c, .S, \u0026hellip;) â€¢ hdl/ containing all the hardware descriptions (.vhd, .v, .sv, \u0026hellip;) â€¢ hdl/tb/ containing all the simulation files (.vhd) â€¢ files like a README.md, vivado_script.tcl, \u0026hellip; â€¢ README.md: if you want to add some additional info â€¢ vivado.tcl: script to automate project creation in Vivado\nIf you look at the structure of how you need to hand in assignments, you might spot something. These are all plain text files and there are not many of them. However, this will enable you to generate all data you need: binaries, hex-files, vivado projects, bitstreams, \u0026hellip; In case you want to use some version control (like GitHub), it would make sense to track only these files.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/900_appendices/",
	"title": "9 Appendices",
	"tags": [],
	"description": "",
	"content": "Appendices "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/900_appendices/901_roger/",
	"title": "901 - Roger &amp; Chip",
	"tags": [],
	"description": "",
	"content": "Within the Engineering Technology program it is sometimes needed to have access to a server. For this purpose, Roger was born. On this server several virtual machines are running. For this course, students can use chip.\nThis server is accessible over the Internet. To be able to connect to the virtual machines a VPN connection is required. You have received (or will receive) an email that contains your username and password.\nOpenVPN-ing To connect to Roger\u0026rsquo;s VPN server, a VPN client should be used (e.g. putty). In case a GUI will be used, an Xserver should be run on your machine. MobaXterm is a tool that provides both an SSH client and an Xserver.\nLog in on Roger which lives at 193.190.58.21 on port 2222 with your login and change your password.\n[jovliegen@roger ~]$ passwd\nMakefile for cross compiling In the Makefile of the example (found here), the cross compiler is set like this:\nThe specific version which was used from GitHub:\nRISCV_GNU_TOOLCHAIN_GIT_REVISION = 8c969a9\nThe path to the installation:\nRISCV_GNU_TOOLCHAIN_INSTALL_PREFIX = /opt/riscv\nThe fixed prefix to the executables, using the previously set variable:\nTOOLCHAIN_PREFIX = $(RISCV_GNU_TOOLCHAIN_INSTALL_PREFIX)/bin/riscv32-unknown-elf-\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/",
	"title": "HWSW codesign",
	"tags": [],
	"description": "",
	"content": "HW/SW codesign Image courtesy: Pexels - DS stories "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]